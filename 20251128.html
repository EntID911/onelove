<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>角色变迁表生成器</title>
    <style>
        :root {
            --chart-base-width: 1000px;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: #000000;
            color: #fff;
            font-family: 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
            position: relative; /* For absolute positioning of the icon */
        }

        /* GitHub Icon Style */
        .github-link {
            position: absolute;
            top: 15px;
            right: 20px;
            width: 32px;
            height: 32px;
            z-index: 1000;
            opacity: 0.5;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .github-link:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .github-link svg {
            width: 100%;
            height: 100%;
            fill: #ffffff;
        }

        /* Preview Area */
        #preview-wrapper {
            width: 100%;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }

        #chart-container {
            width: var(--chart-base-width);
            background-color: #000;
            transform-origin: left top; 
            padding: 60px 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .main-title {
            font-size: 60px;
            font-weight: bold;
            color: white;
            margin-bottom: 50px;
            text-align: center;
            letter-spacing: 4px;
            outline: none;
            border-bottom: 1px dashed transparent;
        }
        .main-title:focus { border-bottom: 1px dashed #666; }

        #grid-target {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 30px;
            width: 100%;
        }

        .year-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .img-box {
            width: 100%;
            aspect-ratio: 3/4;
            background-color: #111;
            border: 2px solid #333;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .img-box.has-image {
            border-color: transparent;
            background-color: #000;
        }

        .img-box img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none;
        }
        .img-box.has-image img { display: block; }

        .img-box::after {
            content: '+';
            font-size: 80px;
            color: #444;
            font-weight: lighter;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -55%);
        }
        .img-box.has-image::after { display: none; }

        .year-label {
            color: #fff;
            font-size: 40px;
            font-weight: bold;
            font-family: 'Times New Roman', serif;
        }

        /* Controls */
        .controls-section {
            width: 100%;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            z-index: 10;
        }

        .input-row {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 14px;
            color: #ccc;
        }

        input[type="number"] {
            background: #222;
            border: 1px solid #444;
            color: white;
            padding: 8px 0;
            border-radius: 4px;
            width: 80px;
            font-size: 18px;
            text-align: center;
            outline: none;
        }

        .btn-save {
            background-color: #333;
            color: #eee;
            border: 1px solid #444;
            padding: 12px 40px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
        }

        /* Cropper Modal */
        #cropper-modal {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background-color: rgba(0,0,0,0.95);
            z-index: 999;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .crop-instruction {
            color: #ddd;
            font-size: 14px;
            margin-bottom: 15px;
            text-align: center;
            background: rgba(255,255,255,0.1);
            padding: 8px 16px;
            border-radius: 20px;
            pointer-events: none;
        }

        .crop-viewport {
            width: 300px;
            height: 400px;
            border: 2px solid #fff;
            box-shadow: 0 0 0 100vmax rgba(0,0,0,0.8);
            position: relative;
            overflow: hidden;
            background: #222;
        }

        #crop-image {
            position: absolute;
            left: 0; top: 0;
            transform-origin: 0 0;
            cursor: grab;
            user-select: none;
        }
        #crop-image:active { cursor: grabbing; }

        .crop-actions {
            margin-top: 30px;
            display: flex;
            gap: 30px;
        }

        .btn-crop {
            padding: 12px 35px;
            border-radius: 30px;
            border: none;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .btn-crop:active { transform: scale(0.95); }

        .btn-cancel { 
            background: #e0e0e0; 
            color: #333; 
        }
        
        .btn-confirm { 
            background: #0088ff; 
            color: #fff; 
            box-shadow: 0 0 10px rgba(0, 136, 255, 0.5);
        }

        canvas { display: none; }
        input[type="file"] { display: none; }
    </style>
</head>
<body>

    <!-- GitHub Corner Icon -->
    <a href="https://github.com/EntID911/onelove" target="_blank" class="github-link" aria-label="View on GitHub">
        <svg viewBox="0 0 98 96" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z"/>
        </svg>
    </a>

    <div id="preview-wrapper">
        <div id="chart-container">
            <div class="main-title" contenteditable="true">最爱角色变迁表</div>
            <div id="grid-target"></div>
        </div>
    </div>

    <div class="controls-section">
        <div class="input-row">
            <span>起始年份</span>
            <input type="number" id="start-year" value="2016" onchange="updateGrid()">
            <span>至 2025</span>
        </div>
        <button class="btn-save" onclick="generateImage()">保存图片</button>
    </div>

    <input type="file" id="global-file-input" accept="image/*">
    <canvas id="renderCanvas"></canvas>
    <canvas id="cropCanvas"></canvas>

    <div id="cropper-modal">
        <div class="crop-instruction">单点以拖动，再点击下方按钮完成，滚轮缩放图片</div>
        <div class="crop-viewport" id="crop-viewport">
            <img id="crop-image" src="" alt="">
        </div>
        <div class="crop-actions">
            <button class="btn-crop btn-cancel" onclick="closeCropper()">取消</button>
            <button class="btn-crop btn-confirm" onclick="confirmCrop()">确定使用</button>
        </div>
    </div>

    <script>
        const END_YEAR = 2025;
        const BASE_WIDTH = 1000;
        const imageStore = {}; 

        let currentEditingYear = null;
        let cropState = {
            imgW: 0, imgH: 0, 
            vpW: 300, vpH: 400, 
            x: 0, y: 0, 
            minX: 0, minY: 0, 
            scale: 1, baseScale: 1, 
            naturalWidth: 0, naturalHeight: 0
        };

        window.addEventListener('load', () => {
            updateGrid();
            window.addEventListener('resize', performScale);
            initCropperEvents(); 
        });

        const fileInput = document.getElementById('global-file-input');
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    openCropper(evt.target.result);
                };
                reader.readAsDataURL(file);
            }
            fileInput.value = ''; 
        });

        function updateGrid() {
            let startYear = parseInt(document.getElementById('start-year').value);
            if (!startYear || startYear > END_YEAR) startYear = 2016;
            if (startYear < 1900) startYear = 1900;

            const grid = document.getElementById('grid-target');
            grid.innerHTML = '';
            const count = END_YEAR - startYear + 1;

            for (let i = 0; i < count; i++) {
                const year = startYear + i;
                const group = document.createElement('div');
                group.className = 'year-group';

                const box = document.createElement('div');
                box.className = 'img-box';
                
                if (imageStore[year]) {
                    box.classList.add('has-image');
                    const img = document.createElement('img');
                    img.src = imageStore[year];
                    img.id = `preview-img-${year}`;
                    box.appendChild(img);
                } else {
                    const img = document.createElement('img');
                    img.id = `preview-img-${year}`;
                    box.appendChild(img);
                }

                box.onclick = () => {
                    currentEditingYear = year;
                    document.getElementById('global-file-input').click();
                };

                const label = document.createElement('div');
                label.className = 'year-label';
                label.innerText = year;

                group.appendChild(box);
                group.appendChild(label);
                grid.appendChild(group);
            }
            setTimeout(performScale, 0);
        }

        // Auto-scale logic for mobile viewports
        function performScale() {
            const wrapper = document.getElementById('preview-wrapper');
            const container = document.getElementById('chart-container');
            const screenW = window.innerWidth;
            const scale = screenW / BASE_WIDTH;
            const finalScale = scale > 1 ? 1 : scale;
            container.style.transform = `scale(${finalScale})`;
            wrapper.style.height = (container.offsetHeight * finalScale) + 'px';
            if (screenW > BASE_WIDTH) {
                container.style.marginLeft = (screenW - BASE_WIDTH) / 2 + 'px';
            } else {
                container.style.marginLeft = '0px';
            }
        }

        // --- Cropper Logic ---

        function openCropper(imgSrc) {
            const modal = document.getElementById('cropper-modal');
            const img = document.getElementById('crop-image');
            img.src = '';
            img.style.transform = `translate(0px, 0px)`;
            
            img.onload = () => {
                resetCropState(img);
                modal.style.display = 'flex';
            };
            img.src = imgSrc;
        }

        function closeCropper() {
            document.getElementById('cropper-modal').style.display = 'none';
        }

        function resetCropState(img) {
            const vpW = 300; 
            const vpH = 400; 
            const nW = img.naturalWidth;
            const nH = img.naturalHeight;
            
            const ratioImg = nW / nH;
            const ratioVp = vpW / vpH;
            
            let renderW, renderH;

            // Initial fitting ('cover' strategy)
            if (ratioImg > ratioVp) {
                renderH = vpH;
                renderW = nW * (vpH / nH);
            } else {
                renderW = vpW;
                renderH = nH * (vpW / nW);
            }

            const currentScale = renderW / nW;

            cropState = {
                vpW, vpH,
                imgW: renderW,
                imgH: renderH,
                naturalWidth: nW,
                naturalHeight: nH,
                scale: currentScale,
                baseScale: currentScale, 
                x: -(renderW - vpW) / 2,
                y: -(renderH - vpH) / 2,
                minX: vpW - renderW,
                minY: vpH - renderH,
                maxX: 0,
                maxY: 0
            };

            updateCropTransform();
        }

        function updateCropTransform() {
            const img = document.getElementById('crop-image');
            img.style.width = cropState.imgW + 'px';
            img.style.height = cropState.imgH + 'px';
            img.style.transform = `translate(${cropState.x}px, ${cropState.y}px)`;
        }

        function initCropperEvents() {
            const viewport = document.getElementById('crop-viewport');
            let isDragging = false;
            let startClientX, startClientY;
            let startStateX, startStateY;

            // Drag Handler
            const handleStart = (clientX, clientY) => {
                isDragging = true;
                startClientX = clientX;
                startClientY = clientY;
                startStateX = cropState.x;
                startStateY = cropState.y;
            };

            const handleMove = (clientX, clientY) => {
                if (!isDragging) return;
                const deltaX = clientX - startClientX;
                const deltaY = clientY - startClientY;

                let newX = startStateX + deltaX;
                let newY = startStateY + deltaY;

                // Boundaries check
                if (newX > cropState.maxX) newX = cropState.maxX;
                if (newX < cropState.minX) newX = cropState.minX;
                if (newY > cropState.maxY) newY = cropState.maxY;
                if (newY < cropState.minY) newY = cropState.minY;

                cropState.x = newX;
                cropState.y = newY;
                updateCropTransform();
            };

            const handleEnd = () => { isDragging = false; };

            // Touch events
            viewport.addEventListener('touchstart', e => { e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
            window.addEventListener('touchmove', e => { if(isDragging) e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
            window.addEventListener('touchend', handleEnd);
            
            // Mouse events
            viewport.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
            window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
            window.addEventListener('mouseup', handleEnd);

            // Wheel Zoom Handler
            viewport.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const zoomSpeed = 0.05;
                const direction = e.deltaY > 0 ? -1 : 1; 
                
                let newScale = cropState.scale + (direction * zoomSpeed * cropState.scale);

                // Limit zoom levels
                if (newScale < cropState.baseScale) newScale = cropState.baseScale;
                if (newScale > cropState.baseScale * 5) newScale = cropState.baseScale * 5;

                const ratio = newScale / cropState.scale;
                
                const newW = cropState.naturalWidth * newScale;
                const newH = cropState.naturalHeight * newScale;

                const viewportCenterX = cropState.vpW / 2;
                const viewportCenterY = cropState.vpH / 2;

                const imgCenterX = (viewportCenterX - cropState.x) * ratio;
                const imgCenterY = (viewportCenterY - cropState.y) * ratio;

                let newX = viewportCenterX - imgCenterX;
                let newY = viewportCenterY - imgCenterY;

                const minX = cropState.vpW - newW;
                const minY = cropState.vpH - newH;
                const maxX = 0;
                const maxY = 0;

                // Adjust positioning to stay within bounds
                if (newX > maxX) newX = maxX;
                if (newX < minX) newX = minX;
                if (newY > maxY) newY = maxY;
                if (newY < minY) newY = minY;

                cropState.scale = newScale;
                cropState.imgW = newW;
                cropState.imgH = newH;
                cropState.x = newX;
                cropState.y = newY;
                cropState.minX = minX;
                cropState.minY = minY;
                
                updateCropTransform();
            });
        }

        function confirmCrop() {
            const canvas = document.getElementById('cropCanvas');
            const ctx = canvas.getContext('2d');
            const img = document.getElementById('crop-image');

            // Render to a temporary canvas for high quality crop
            const targetW = 600;
            const targetH = 800; // 3:4 aspect

            canvas.width = targetW;
            canvas.height = targetH;

            const sx = Math.abs(cropState.x) / cropState.scale;
            const sy = Math.abs(cropState.y) / cropState.scale;
            
            const sWidth = cropState.vpW / cropState.scale;
            const sHeight = cropState.vpH / cropState.scale;

            ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, targetW, targetH);

            const croppedBase64 = canvas.toDataURL('image/jpeg', 0.95);

            if (currentEditingYear) {
                imageStore[currentEditingYear] = croppedBase64;
                const previewImg = document.getElementById(`preview-img-${currentEditingYear}`);
                if (previewImg) {
                    previewImg.src = croppedBase64;
                    previewImg.parentElement.classList.add('has-image');
                }
            }
            closeCropper();
        }

        // Final Canvas Generation
        function generateImage() {
            const canvas = document.getElementById('renderCanvas');
            const ctx = canvas.getContext('2d');
            const startYear = parseInt(document.getElementById('start-year').value);
            const title = document.querySelector('.main-title').innerText;
            const count = END_YEAR - startYear + 1;

            const OUT_W = 1920;
            const COLS = 5;
            const MARGIN_X = 100;
            const MARGIN_TOP = 200;
            const GAP = 40;
            const CELL_W = (OUT_W - (MARGIN_X * 2) - (GAP * (COLS - 1))) / COLS;
            const CELL_H = CELL_W / 0.75; 
            const ROW_H = CELL_H + 120; 
            const ROWS = Math.ceil(count / COLS);
            const OUT_H = MARGIN_TOP + (ROWS * ROW_H) + 50;

            canvas.width = OUT_W;
            canvas.height = OUT_H;

            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, OUT_W, OUT_H);

            ctx.fillStyle = "#ffffff";
            ctx.textAlign = "center";
            ctx.font = "bold 80px 'Microsoft YaHei'";
            ctx.fillText(title, OUT_W / 2, 120);

            for (let i = 0; i < count; i++) {
                const year = startYear + i;
                const col = i % COLS;
                const row = Math.floor(i / COLS);
                const x = MARGIN_X + col * (CELL_W + GAP);
                const y = MARGIN_TOP + row * ROW_H;

                ctx.fillStyle = "#111111";
                ctx.fillRect(x, y, CELL_W, CELL_H);

                if (imageStore[year]) {
                    const img = new Image();
                    img.src = imageStore[year];
                    ctx.drawImage(img, x, y, CELL_W, CELL_H);
                } else {
                    ctx.fillStyle = "#333";
                    ctx.font = "100px sans-serif";
                    ctx.textAlign = "center";
                    ctx.fillText("+", x + CELL_W/2, y + CELL_H/2 + 30);
                }

                ctx.fillStyle = "#ffffff";
                ctx.textAlign = "center";
                ctx.font = "bold 50px 'Times New Roman', serif";
                ctx.fillText(year, x + CELL_W / 2, y + CELL_H + 70);
            }

            try {
                const link = document.createElement('a');
                link.download = `角色变迁表_${startYear}-${END_YEAR}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            } catch (e) { alert("生成失败"); }
        }
    </script>
</body>
</html>